# -*- coding: utf-8 -*-
"""2022254_3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/kriishukla/2022254-3.ebff4175-4f82-4233-b9fe-dbc8b7bdbc25.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250405/auto/storage/goog4_request%26X-Goog-Date%3D20250405T054051Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3Db9c6720a1a878b78d7e034ebff40514a38010f5a8bd50bfdfdef51604a3a9727dc78249295f6d67d733e682fdd13b62c3dcf95720baf5527d42f6b965218d11853d2fcdd347c954c96add48c2d926205cf21813741b747d6c5c24d17fc9a98170004c48bd69f2faab2501c49d2f6c8c33a1be81143346b2b5353aa6b492be027c003d9dc1b90137fa7298583b71655e33f591cda22fb3e793daaea5b14246dfabd7cd88dd1301137486cfd626ec9728bd2c3df1c20d18e27dbe64a9ccbace0c75308f72cd951c4040337933ee54a1ccad3668a180f842c45c8e9e4224b8a19416e2588aaaa445c9afa1e73540efaf7a16a654da9169b2301d7b20cb6abdc0813
"""

# IMPORTANT: SOME KAGGLE DATA SOURCES ARE PRIVATE
# RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES.
import kagglehub
kagglehub.login()

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

kriishukla_chess_board_path = kagglehub.dataset_download('kriishukla/chess-board')

print('Data source import complete.')

import numpy as np
import matplotlib.pyplot as plt
import os
import cv2
import json

DIR_PATH = r"/kaggle/input/chess-board/chessboard_dataset-20250402T180104Z-001/chessboard_dataset"

image_names = []
my_cnt=0
for name in os.listdir(DIR_PATH):
    if name.lower().endswith(('.png', '.jpg', '.jpeg')):
        image_names.append(os.path.join(DIR_PATH, name))

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

objp = np.zeros((8 * 6, 3), np.float32)
objp[:, :2] = np.mgrid[0:8, 0:6].T.reshape(-1, 2)

alpha=0


objpoints = []
imgpoints = []

for image_name in image_names:
    img = cv2.imread(image_name)

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)
    my_cnt+=1

    objpoints.append(objp)
    corners2 = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
    imgpoints.append(corners2)

    img = cv2.drawChessboardCorners(img, (8, 6), corners2, ret)
    my_cnt+=1
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))

    plt.show()

cv2.destroyAllWindows()

ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

fx = mtx[0, 0]
fy = mtx[1, 1]
cx = mtx[0, 2]
ax = mtx[2, 0]
cy = mtx[1, 2]
s =  mtx[0, 1]
qx=mtx[2,2]
print("Camera matrix : \n")
print(mtx)
print("fx = ", fx)
print("fy = ", fy)
print("cx = ", cx)
print("cy = ", cy)
print("s = ", s)

for i in range(len(objpoints)):
    rotation_matrix, _ = cv2.Rodrigues(rvecs[i])
    print(f'{image_names[i]}:')
    print('Rotation Matrix:')
    print(rotation_matrix)
    print('Translation Vector:')
    print(tvecs[i])
    print()

for i in range(len(objpoints)):
    if image_names[i] == '/kaggle/input/chess-board/chessboard_dataset-20250402T180104Z-001/chessboard_dataset/1.jpeg':
        rotation_matrix1, _ = cv2.Rodrigues(rvecs[i])
        print(f'{image_names[i]}:')
        print('Rotation Matrix:')
        print(rotation_matrix)
        print('Translation Vector:')
        tvex1=tvecs[i]
        print(tvecs[i])
        print()
print(rotation_matrix1)

for i in range(len(objpoints)):
    if image_names[i] == '/kaggle/input/chess-board/chessboard_dataset-20250402T180104Z-001/chessboard_dataset/2.jpeg':
        rotation_matrix2, _ = cv2.Rodrigues(rvecs[i])
        print(f'{image_names[i]}:')
        print('Rotation Matrix:')
        print(rotation_matrix)
        print('Translation Vector:')
        tvex2=tvecs[i]
        print(tvecs[i])
        print()

k=dist
print(f'Distortion coefficients: {k}')

i = 0
while i < 5:
    img = cv2.imread(image_names[i])
    dst = cv2.undistort(img, mtx, dist, None, mtx)

    fig, (ax1, ax2) = plt.subplots(1, 2)
    ax1.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    ax1.set_title('Original Image')
    ax2.imshow(cv2.cvtColor(dst, cv2.COLOR_BGR2RGB))
    ax2.set_title('Undistorted Image')

    plt.show()
    i += 1

reprojection_errors = []

i = 0
while i < len(objpoints):
    img = cv2.imread(image_names[i])
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
    imgpoints2 = imgpoints2.reshape(-1, 2)

    # Convert imgpoints to the same data type as imgpoints2
    imgpoints[i] = np.array(imgpoints[i]).reshape(-1, 2)

    error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2) / len(imgpoints2)
    reprojection_errors.append(error)

    i += 1

q=len(reprojection_errors)
plt.bar(range(q), reprojection_errors)
plt.xlabel('Image Index')
plt.ylabel('Re-projection Error')
plt.title('Re-projection Error for Each Image')
plt.show()

mean=np.mean(reprojection_errors)
mean_error = mean
std_error = np.std(reprojection_errors)
std=std_error
print(f"Mean re-projection error: {mean}")
print(f"Standard deviation of re-projection error: {std_error}")

i = 0
while i < len(objpoints):
    img = cv2.imread(image_names[i])
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert to RGB for matplotlib

    img_detected = cv2.drawChessboardCorners(img.copy(), (7, 6), imgpoints[i], True)

    imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
    imgpoints2 = imgpoints2.reshape(-1, 2)
    img_reprojected = cv2.drawChessboardCorners(img.copy(), (7, 6), imgpoints2, True)

    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(img_detected)
    plt.title('Detected Corners')
    plt.subplot(1, 2, 2)
    plt.imshow(img_reprojected)
    plt.title('Reprojected Corners')
    plt.show()

    i += 1

i = 0
while i < len(objpoints):
    rotation_matrix, _ = cv2.Rodrigues(rvecs[i])
    normal = rotation_matrix[:, 2]

    print(f'{image_names[i]}:')
    print(f'Plane Normal: {normal}')
    i += 1

print(k)

print(tvex1)
print(tvex2)

tvex2[2][0]

json_res = {
    "intrinsic_parameters": {
        "focal_length": [
            fx,
            fy
        ],
        "skew": s,
        "principal_point": [
            cx,
            cy
        ]
    },
    "extrinsic_parameters": [
        {
            "image_id": 1,
            "rotation_matrix": rotation_matrix1.tolist(),
            "translation_vector": [
                tvex1[0][0],
                tvex1[1][0],
                tvex1[2][0]
            ]
        },
        {
            "image_id": 2,
            "rotation_matrix": rotation_matrix2.tolist() ,
            "translation_vector":  [
                tvex2[0][0],
                tvex2[1][0],
                tvex2[2][0]
            ]
        }
    ],
    "radial_distortion_coefficients": [
        k[0][0],
        k[0][1],
        k[0][4]
    ],
    "reprojection_errors": {
        "mean_error": mean_error,
        "std_dev": std
    }
}

# Saving the JSON to a file
json_file_path = "/kaggle/working/calibration_results.json"
with open(json_file_path, 'w') as json_file:
    json.dump(json_res, json_file, indent=4)

print(f"Calibration results saved to {json_file_path}")

print(image_names)

"""**MY DATASET**"""

import numpy as np
import matplotlib.pyplot as plt
import os
import cv2

DIR_PATH = r"/kaggle/input/chess-board/Dataset2/Dataset2"

image_names = []
my_cnt = 0
for name in os.listdir(DIR_PATH):
    if name.lower().endswith(('.png', '.jpg', '.jpeg')):
        image_names.append(os.path.join(DIR_PATH, name))

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

objp = np.zeros((8 * 6, 3), np.float32)
objp[:, :2] = np.mgrid[0:8, 0:6].T.reshape(-1, 2)

alpha = 0

objpoints = []
imgpoints = []

for image_name in image_names:
    if image_name == "/kaggle/input/chess-board/Dataset2/Dataset2/IMG-20250404-WA0042.jpg" or \
       image_name == "/kaggle/input/chess-board/Dataset2/Dataset2/IMG-20250404-WA0070.jpg" or \
       image_name == "/kaggle/input/chess-board/Dataset2/Dataset2/IMG-20250404-WA0065.jpg":
        continue
    if image_name == "/kaggle/input/chess-board/Dataset2/Dataset2/IMG-20250404-WA0072.jpg":
        continue

    print(image_name)
    img = cv2.imread(image_name)

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)
    my_cnt += 1

    # Check if corners were found
    if ret:
        objpoints.append(objp)
        corners2 = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
        imgpoints.append(corners2)

        img = cv2.drawChessboardCorners(img, (8, 6), corners2, ret)
        my_cnt += 1
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.show()
    else:
        print(f"Corners not found in image {image_name}. Skipping.")

cv2.destroyAllWindows()

# After collecting the object points and image points, proceed with calibration
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

fx = mtx[0, 0]
fy = mtx[1, 1]
cx = mtx[0, 2]
ax = mtx[2, 0]
cy = mtx[1, 2]
s =  mtx[0, 1]
qx=mtx[2,2]
print("Camera matrix : \n")
print(mtx)
print("fx = ", fx)
print("fy = ", fy)
print("cx = ", cx)
print("cy = ", cy)
print("s = ", s)

print(len(objpoints))

for i in range(len(objpoints)):
    rotation_matrix, _ = cv2.Rodrigues(rvecs[i])
    print(f'{image_names[i]}:')
    print('Rotation Matrix:')
    print(rotation_matrix)
    print('Translation Vector:')
    print(tvecs[i])
    print()

k=dist
print(f'Distortion coefficients: {k}')

i = 0
while i < 5:
    img = cv2.imread(image_names[i])
    dst = cv2.undistort(img, mtx, dist, None, mtx)

    fig, (ax1, ax2) = plt.subplots(1, 2)
    ax1.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    ax1.set_title('Original Image')
    ax2.imshow(cv2.cvtColor(dst, cv2.COLOR_BGR2RGB))
    ax2.set_title('Undistorted Image')

    plt.show()
    i += 1

reprojection_errors = []

i = 0
while i < len(objpoints):
    img = cv2.imread(image_names[i])
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
    imgpoints2 = imgpoints2.reshape(-1, 2)

    # Convert imgpoints to the same data type as imgpoints2
    imgpoints[i] = np.array(imgpoints[i]).reshape(-1, 2)

    error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2) / len(imgpoints2)
    reprojection_errors.append(error)

    i += 1

q=len(reprojection_errors)
plt.bar(range(q), reprojection_errors)
plt.xlabel('Image Index')
plt.ylabel('Re-projection Error')
plt.title('Re-projection Error for Each Image')
plt.show()

mean=np.mean(reprojection_errors)
mean_error = mean
std_error = np.std(reprojection_errors)
std=std_error
print(f"Mean re-projection error: {mean}")
print(f"Standard deviation of re-projection error: {std_error}")

i = 0
while i < len(objpoints):
    img = cv2.imread(image_names[i])
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert to RGB for matplotlib

    img_detected = cv2.drawChessboardCorners(img.copy(), (7, 6), imgpoints[i], True)

    imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
    imgpoints2 = imgpoints2.reshape(-1, 2)
    img_reprojected = cv2.drawChessboardCorners(img.copy(), (7, 6), imgpoints2, True)

    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(img_detected)
    plt.title('Detected Corners')
    plt.subplot(1, 2, 2)
    plt.imshow(img_reprojected)
    plt.title('Reprojected Corners')
    plt.show()

    i += 1

i = 0
while i < len(objpoints):
    rotation_matrix, _ = cv2.Rodrigues(rvecs[i])
    normal = rotation_matrix[:, 2]

    print(f'{image_names[i]}:')
    print(f'Plane Normal: {normal}')
    i += 1

